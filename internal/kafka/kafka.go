package kafka

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	env "github.com/csye7125-su24-team06/webapp-cve-consumer/internal"
	"github.com/csye7125-su24-team06/webapp-cve-consumer/internal/function"
	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/scram"
)

type KafkaConsumerInterface interface {
	Consume()
	Close() error
	Ping() error
}

type kafkaConsumer struct {
	client   *kafka.Reader
	conn     *kafka.Conn
	topic    string
	isClosed bool
}

var KafkaConsumerObject KafkaConsumerInterface

func GetKafkaConsumer() KafkaConsumerInterface {

	topic := env.GetEnvOrDefault("KAFKA_TOPIC", "cve")
	brokersEnv := env.GetEnvOrDefault("KAFKA_BROKERS", "localhost:9092,localhost:9093,localhost:9094")
	brokers := strings.Split(brokersEnv, ",")
	group_id := env.GetEnvOrDefault("KAFKA_CONSUMER_GROUP_ID", "cve")
	maxBytes, err := strconv.ParseFloat(env.GetEnvOrDefault("KAFKA_MAX_SIZE", "10e6"), 64)
	if err != nil {
		panic(fmt.Sprintf("Invalid Max Bytes : %v", err))
	}

	dialer := &kafka.Dialer{
		Timeout:   10 * time.Second,
		DualStack: true,
	}

	username := env.GetEnvOrDefault("KAFKA_USERNAME", "")
	password := env.GetEnvOrDefault("KAFKA_PASSWORD", "")
	if username != "" || password != "" {
		auth, err := scram.Mechanism(scram.SHA512, username, password)
		if err != nil {
			log.Fatalf("Failed to create auth: %v", err)
		}
		dialer.SASLMechanism = auth
	}

	conn, err := dialer.DialContext(context.Background(), "tcp", brokers[0])
	if err != nil {
		log.Fatalf("Failed to create kafka connection: %v", err)
	}

	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  brokers,
		GroupID:  group_id,
		Topic:    topic,
		MaxBytes: int(maxBytes),
		Dialer:   dialer,
	})

	KafkaConsumerObject = &kafkaConsumer{
		client:   r,
		conn:     conn,
		topic:    topic,
		isClosed: false,
	}

	return KafkaConsumerObject
}

func (kc *kafkaConsumer) Consume() {
	fmt.Println("Starting Kafka Consumer...")
	for {
		m, err := kc.client.FetchMessage(context.Background())
		if err != nil && !kc.isClosed {
			panic(fmt.Sprintf("Kafka Client Faliure : %v", err))
		}

		function.ProcessCve(&m.Value)

		if err := kc.client.CommitMessages(context.Background(), m); err != nil && !kc.isClosed {
			panic(fmt.Sprintf("Kafka Client Failed to commit message : %v", err))
		}
	}
}

func (kc *kafkaConsumer) Close() error {
	kc.isClosed = true

	if err := kc.client.Close(); err != nil {
		return err
	}

	if err := kc.conn.Close(); err != nil {
		return err
	}

	return nil
}

func (kc *kafkaConsumer) Ping() error {
	partitions, err := kc.conn.ReadPartitions()
	if err != nil {
		return err
	}

	for _, partition := range partitions {
		if partition.Topic == kc.topic {
			return nil
		}
	}

	return errors.New("unable to find topic")
}
