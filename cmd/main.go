package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"

	env "github.com/csye7125-su24-team06/webapp-cve-consumer/internal"
	"github.com/csye7125-su24-team06/webapp-cve-consumer/internal/api"
	"github.com/csye7125-su24-team06/webapp-cve-consumer/internal/kafka"
	"github.com/csye7125-su24-team06/webapp-cve-consumer/pkg/database"
	"github.com/joho/godotenv"
)

func main() {

	env.Init()

	// Graceful Shutdown
	gracefulShutdown()

	godotenv.Load()

	// Consumer for Kafka
	go func() {
		env.GlobalContextInstance.SetAlive()
		defer env.GlobalContextInstance.Close()

		// Initializing Postgres
		database.InitPostgres()

		// Restarting consumer when it is not closed
		count := 0
		for kafka.KafkaConsumerObject == nil || !kafka.KafkaConsumerObject.IsClosed() {
			log.Printf("Starting Consumer. Restart counter: %v \n", count)
			kafka.GetKafkaConsumer().Consume()
			count += 1
		}
	}()

	api.StartServer()
}

func gracefulShutdown() {
	sigc := make(chan os.Signal, 1)
	signal.Notify(sigc,
		syscall.SIGHUP,
		syscall.SIGINT,
		syscall.SIGTERM,
		syscall.SIGQUIT)

	go func() {
		<-sigc

		log.Println("Disconnecting Database...")

		if database.DataSource != nil {
			pgDB, err := database.DataSource.DB()
			if err != nil {
				log.Println("DB Object not found")
			} else {
				if err = pgDB.Close(); err != nil {
					log.Println("DB Connection was not closed")
				}
			}
		}

		log.Println("Disconnecting Kafka Client...")
		if kafka.KafkaConsumerObject != nil {
			if err := kafka.KafkaConsumerObject.Close(); err != nil {
				log.Println("Kafka consumer close failure")
			}
		}

		log.Println("Shutting Down Server...")
		if err := api.Server.Close(); err != nil {
			log.Println("Server close failure")
		}

		log.Println("Cleanup Completed!")
		os.Exit(0)
	}()
}
